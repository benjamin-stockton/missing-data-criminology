---
title: 'Small Simulation: Effect of Missing Data'
author: "Ben Stockton"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, results = 'hold')

library(ggplot2)
library(cowplot)
library(latex2exp)
library(dplyr)
library(doParallel)

cores <- detectCores()

source("small_sim_functions.R")
```

## Simulation Process

Set $\beta = (\beta_0, \beta_X, ...)'$ and `Q` the number of iterations.

For each iteration `q`:

1. Generate a new data set containing $Y$, $X$, and $CTY$. 

    - $CTY$ is a "county" variable with four levels. Level 3 is the reference level.
    - $X$ is binary determined by a $CTY$. The probability $X$ is 1 depends on $CTY$ with $CTY = 1$ having probability .05 to $CTY = 4$ having probability .65.
    - $Y$ is randomly drawn from the Bernoulli distribution with probability $$(1 + \exp(-(1, X, CTY) \beta))^{-1}$$

2. Missingness is then generated in $X$ to create "Overstated" (OVER) and "Understated" (UNDR) X effects based on the type of missingness (MAR/MNAR).
3. Logistic regressions $logit(E(Y)) = (1, X, CTY)\beta$ are fit on the complete simulated data set, the OVER data set, and the UNDR data set. For each regression, the Odds Ratio and Proportion of Missingness are recorded and used to calculate the Bias $\hat{OR}_{MissType} - \beta_X$ and difference between the missing data set estimate and the complete data set estimate $\hat{OR}_{MissType} - \hat{OR}_{Comp}$.
4. Repeat for `Q` iterations.

## Test

Testing the simulation helper functions. First is the function to generate simulated data:
```{r}
set.seed(987)
M <- 1000
beta <- c(.05, 3, -.2, 0, -.05)
test.df <- generate_data(beta = beta, M = M)
test.df %>% head()
```

Then generation of missingness in $X$:

```{r}
x.miss <- generate_missing_x(test.df, "MAR")
str(x.miss)
x.miss[["COMP"]][1:10]
```

Testing each logistic regression which returns the $(OddsRatio, PropMiss)'$:
```{r}
sim_log_reg(test.df, x.miss, "COMP")
sim_log_reg(test.df, x.miss, "OVER")
sim_log_reg(test.df, x.miss, "UNDR")
```

Testing the full simulation:

```{r}
a <- -6; b <- 4
(1 + exp(-(a + b * (1))))^-1
(1 + exp(-(a + b * (0))))^-1
```

```{r}
source("small_sim_functions.R")
full_sim(miss_type = "MNAR", beta = beta, Q = 1, a = a, b = b)
full_sim(miss_type = "MAR", beta = beta, Q = 1, a = a, b = b)
```

---

```{r}
M <- 1000
beta <- c(.05, .227, -.2, 0, -.05)
```


## MNAR

Want to get roughly 3-5% missing in X in both cases.

Overstate the X effect:

$$p_i = P(X_i ~ Missing | Y_i, X_i) = [1 + \exp(-(a + b (1 - X_i) Y_i))]^{-1}$$

Understate the X effect:

$$p_i = P(X_i ~ Missing | Y_i, X_i) = [1 + \exp(-(a+b (1 - X_i) (1 - Y_i)))]^{-1}$$

For both cases we set `a` to `r a` and `b` to `r b` to get between 3-5% missingness in $X$. 

For example, setting $a = -4.25$ and $b = 2$, we get $P(X_i ~ Missing | Y_i, X_i) = 0.095$ and $P(X_i ~ Missing | Y_i, X_i) = 0.014$ resulting in roughly 3-5% missing in $X$.

With these probabilities for each observation, draw from a $Bernoulli(p_i)$ distribution for each observation to determine if $X_i$ is missing.

```{r}
cl <- makeCluster(cores[1] - 1)
registerDoParallel(cl)
ptime <- system.time({
    mnar <- foreach(i = 1:6, .combine = rbind) %dopar% {
        source("helpers.R")
        full_sim(miss_type = "MNAR", beta = beta, Q = 50, a = a, b = b)
    }
})[3]
ptime
stopCluster(cl)
```

---

## MAR

Want to get roughly 3% missing in X in both cases.

Overstate the X effect:

Create $Z_{i1} = (X_i == 0 ~\& ~Y_i == 1)$ and calculate the logistic regression of $Z_1$ on $CTY$. Use the predicted probabilities $\mathbf{p} = (p_1,..,p_N)'$ to sample from a $Bernoulli(p_i)$ distribution for each observation to determine if $X_i$ is missing.

Understate the X effect:

Similarly, create $Z_{i2} = (X_i == 1 ~\& ~Y_i == 1)$ and repeat the process to determine if $X_i$ is missing.

```{r}
cl <- makeCluster(cores[1] - 1)
registerDoParallel(cl)
stime <- system.time({
    mar <- foreach(i = 1:6, .combine = rbind) %dopar% {
        source("helpers.R")
        full_sim(miss_type = "MAR", beta = beta, Q = 50, a = a, b = b)
    }
})[3]
stime
stopCluster(cl)
```

---

## Results

### Tables

```{r, echo = FALSE}
sim.res <- rbind(mnar, mar)

mean_OR <- sim.res %>% group_by(MISS_TYPE, DIRECTION) %>%
    summarize(odds_ratio_mean = round(mean(ODDS_RATIO), 3),
              quant_025 = quantile(ODDS_RATIO, probs = .025),
              quant_975 = quantile(ODDS_RATIO, probs = .975))
mean_OR

mean_PM <- sim.res %>% group_by(MISS_TYPE, DIRECTION) %>%
    summarize(prop_miss_mean = round(mean(PROP_MISS), 3),
              quant_025 = quantile(PROP_MISS, probs = .025),
              quant_975 = quantile(PROP_MISS, probs = .975))
mean_PM

mean_DIFF <- sim.res %>% group_by(MISS_TYPE, DIRECTION) %>%
    summarize(odds_ratio_diff_mean = round(mean(OR_DIFF), 3),
              quant_025 = quantile(OR_DIFF, probs = .025),
              quant_975 = quantile(OR_DIFF, probs = .975))
mean_DIFF

mean_BIAS <- sim.res %>% group_by(MISS_TYPE, DIRECTION) %>%
    summarize(bias_mean = round(mean(OR_BIAS), 3),
              quant_025 = quantile(OR_BIAS, probs = .025),
              quant_975 = quantile(OR_BIAS, probs = .975))
mean_BIAS
```


### Plots

```{r echo = FALSE}
plts <- result_plots(sim.res)

cowplot::plot_grid(plts$OR, plts$PM, nrow = 2)

cowplot::plot_grid(plts$DIFF, plts$BIAS, nrow = 2)
```



```{r echo = FALSE}
# or_bias_diff <- ggplot(sim.res, aes(x = OR_BIAS, y = OR_DIFF, color = DIRECTION)) +
#     geom_point() +
#     facet_grid(MISS_TYPE ~ DIRECTION)
# 
# cowplot::plot_grid(bias_plt, or_bias_diff, nrow = 2)
```

